<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <title>IntMap - FSharpx Documentation</title>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
    <link type="text/css" rel="stylesheet" href="../main.css"/>
    <script type="text/javascript" src="../js/jquery-1.3.2.min.js"></script>
    <script type="text/javascript" src="../js/jquery.scrollTo-min.js"></script>
    <script type="text/javascript" src="../js/navigation.js"></script>
    <script type="text/javascript" src="../js/example.js"></script>
  </head>
  <body><div id="namespaces">
	<h2 class="fixed">Namespaces</h2>
	<div class="scroll">
		<ul>
			<li>
          <a href="../FSharp.Control/index.htm">FSharp.Control</a>
      </li>
			<li>
          <a href="../FSharp.IO/index.htm">FSharp.IO</a>
      </li>
			<li>
          <a href="../FSharpx/index.htm">FSharpx</a>
      </li>
			<li>
          <a href="../FSharpx.Collections/index.htm">FSharpx.Collections</a>
      </li>
			<li>
          <a href="../FSharpx.Collections.Mutable/index.htm">FSharpx.Collections.Mutable</a>
      </li>
			<li>
          <a href="../FSharpx.Core/index.htm">FSharpx.Core</a>
      </li>
			<li>
          <a href="../FSharpx.DataStructures/index.htm" class="current">FSharpx.DataStructures</a>
      </li>
			<li>
          <a href="../FSharpx.Linq/index.htm">FSharpx.Linq</a>
      </li>
			<li>
          <a href="../Microsoft.FSharp.Collections/index.htm">Microsoft.FSharp.Collections</a>
      </li>
			<li>
          <a href="../Microsoft.FSharp.Control/index.htm">Microsoft.FSharp.Control</a>
      </li>
		</ul>
	</div>
</div><div id="types">
  <h2 class="fixed">Types in FSharpx.DataStructures</h2>
	<div class="scroll">
		<ul>
				<li>
            <a href="../FSharpx.DataStructures/AltBinaryRandomAccessListModule.htm">AltBinaryRandomAccessListModule</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/AltBinRndAccList`1.htm">AltBinRndAccList&lt;a&gt;</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/BankersDeque`1.htm">BankersDeque&lt;a&gt;</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/BankersDequeModule.htm">BankersDequeModule</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/BankersQueue`1.htm">BankersQueue&lt;a&gt;</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/BankersQueueModule.htm">BankersQueueModule</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/BatchedDeque`1.htm">BatchedDeque&lt;a&gt;</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/BatchedDequeModule.htm">BatchedDequeModule</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/BatchedQueue`1.htm">BatchedQueue&lt;a&gt;</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/BatchedQueueModule.htm">BatchedQueueModule</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/BinaryRandomAccessList`1.htm">BinaryRandomAccessList&lt;a&gt;</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/BinaryRandomAccessListModule.htm">BinaryRandomAccessListModule</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/BinaryTree`1.htm">BinaryTree`1</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/BinaryTreeZipper.htm">BinaryTreeZipper</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/BinaryTreeZipper`1.htm">BinaryTreeZipper`1</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/BinomialHeap.htm">BinomialHeap</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/BinomialHeap`1.htm">BinomialHeap&lt;a&gt;</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/BinomialTree`1.htm">BinomialTree&lt;a&gt;</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/BKTree.htm">BKTree</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/BKTree`1.htm">BKTree&lt;a&gt;</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/BootstrappedQueue.htm">BootstrappedQueue</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/BootstrappedQueue`1.htm">BootstrappedQueue`1</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/BottomUpMergeSort.htm">BottomUpMergeSort</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/Deque`1.htm">Deque&lt;a&gt;</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/DequeModule.htm">DequeModule</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/Digit`1.htm">Digit&lt;a&gt;</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/DList`1.htm">DList&lt;a&gt;</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/DListModule.htm">DListModule</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/Exceptions.htm">Exceptions</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/Functions`1.htm">Functions`1</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/HeapPriorityQueue.htm">HeapPriorityQueue</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/HoodMelvilleQueue`1.htm">HoodMelvilleQueue&lt;a&gt;</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/HoodMelvilleQueueModule.htm">HoodMelvilleQueueModule</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/IDeque`1.htm">IDeque`1</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/IHeap`1.htm">IHeap`1</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/IHeap`2.htm">IHeap`2</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/ImplicitQueue.htm">ImplicitQueue</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/ImplicitQueue`1.htm">ImplicitQueue`1</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/Interfaces.htm">Interfaces</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/IntMap.htm" class="current">IntMap</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/IPriorityQueue`1.htm">IPriorityQueue`1</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/IQueue`1.htm">IQueue`1</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/IRandomAccessList`1.htm">IRandomAccessList`1</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/IVector`1.htm">IVector`1</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/LazyListHelpr.htm">LazyListHelpr</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/LeftistHeap`1.htm">LeftistHeap&lt;a&gt;</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/LeftistHeapModule.htm">LeftistHeapModule</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/ListHelpr.htm">ListHelpr</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/ListZipper.htm">ListZipper</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/ListZipper`1.htm">ListZipper`1</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/NonEmptyBootstrappedQueue`1.htm">NonEmptyBootstrappedQueue`1</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/PairingHeap`1.htm">PairingHeap&lt;a&gt;</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/PairingHeapModule.htm">PairingHeapModule</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/PhysicistQueue`1.htm">PhysicistQueue&lt;a&gt;</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/PhysicistQueueModule.htm">PhysicistQueueModule</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/RealTimeDeque.htm">RealTimeDeque</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/RealTimeDeque`1.htm">RealTimeDeque&lt;a&gt;</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/RealTimeQueue.htm">RealTimeQueue</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/RealTimeQueue`1.htm">RealTimeQueue`1</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/RingBuffer.htm">RingBuffer</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/RingBuffer`1.htm">RingBuffer&lt;a&gt;</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/RoseTree`1.htm">RoseTree&lt;a&gt;</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/RoseTreeModule.htm">RoseTreeModule</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/RotationState`1.htm">RotationState&lt;a&gt;</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/SkewBinaryRandomAccessList`1.htm">SkewBinaryRandomAccessList&lt;a&gt;</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/SkewBinaryRandomAccessListModule.htm">SkewBinaryRandomAccessListModule</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/Sortable`1.htm">Sortable`1</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/Tags.htm">Tags</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/Timeseries`1.htm">Timeseries&lt;a&gt;</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/TreeBRAL`1.htm">TreeBRAL&lt;a&gt;</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/TreeDirection.htm">TreeDirection</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/TreeSBRAL`1.htm">TreeSBRAL&lt;a&gt;</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/TreeZipperDirection.htm">TreeZipperDirection</a>
        </li>
				<li>
            <a href="../FSharpx.DataStructures/Vector.htm">Vector</a>
        </li>
		</ul>
	</div>
</div>
    <div class="header">
		<p class="class"><strong>Type</strong> IntMap</p>
		<p><strong>Namespace</strong> FSharpx.DataStructures</p>
	</div>
    <div class="sub-header">
		
		
			<h3 class="section">Methods</h3>
			<ul>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#adjust``1">adjust&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#adjustWithKey``1">adjustWithKey&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#alter``1">alter&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#append``1">append&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#appendWith``1">appendWith&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#appendWithKey``1">appendWithKey&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#concat``1">concat&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#concatWith``1">concatWith&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#delete``1">delete&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#deleteFindMax``1">deleteFindMax&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#deleteFindMin``1">deleteFindMin&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#deleteMax``1">deleteMax&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#deleteMin``1">deleteMin&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#difference``2">difference&lt;a, b&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#differenceWith``2">differenceWith&lt;a, b&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#differenceWithKey``2">differenceWithKey&lt;a, b&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#exists``1">exists&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#filter``1">filter&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#filterWithKey``1">filterWithKey&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#find``1">find&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#findMax``1">findMax&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#findMin``1">findMin&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#findWithDefault``1">findWithDefault&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#foldBack``2">foldBack&lt;a, b&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#foldBackWithKey``2">foldBackWithKey&lt;a, b&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#foldWithKey``2">foldWithKey&lt;a, b&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#insert``1">insert&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#insertTryFindWithKey``1">insertTryFindWithKey&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#insertWith``1">insertWith&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#insertWithKey``1">insertWithKey&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#intersection``2">intersection&lt;a, b&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#intersectionWith``3">intersectionWith&lt;a, b, c&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#intersectionWithKey``3">intersectionWithKey&lt;a, b, c&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#isEmpty``1">isEmpty&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#isProperSubmapOf``1">isProperSubmapOf&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#isProperSubmapOfBy``2">isProperSubmapOfBy&lt;a, b&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#isSubmapOf``1">isSubmapOf&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#isSubmapOfBy``2">isSubmapOfBy&lt;a, b&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#keys``1">keys&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#map``2">map&lt;a, b&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#mapAccum``3">mapAccum&lt;a, b, c&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#mapAccumWithKey``3">mapAccumWithKey&lt;a, b, c&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#mapChoice``3">mapChoice&lt;a, b, c&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#mapChoiceWithKey``3">mapChoiceWithKey&lt;a, b, c&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#mapKeys``1">mapKeys&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#mapKeysWith``1">mapKeysWith&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#mapOption``2">mapOption&lt;a, b&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#mapOptionWithKey``2">mapOptionWithKey&lt;a, b&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#mapWithKey``2">mapWithKey&lt;a, b&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#maxView``1">maxView&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#maxViewWithKey``1">maxViewWithKey&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#mergeWithKey``3">mergeWithKey&lt;a, b, c&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#minView``1">minView&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#minViewWithKey``1">minViewWithKey&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#monoid``1">monoid&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#notExists``1">notExists&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#ofArray``1">ofArray&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#ofArrayWith``1">ofArrayWith&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#ofArrayWithKey``1">ofArrayWithKey&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#ofListWith``1">ofListWith&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#ofListWithKey``1">ofListWithKey&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#ofSeqWith``1">ofSeqWith&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#ofSeqWithKey``1">ofSeqWithKey&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#partition``1">partition&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#partitionWithKey``1">partitionWithKey&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#singleton``1">singleton&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#size``1">size&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#split``1">split&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#splitTryFind``1">splitTryFind&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#toArray``1">toArray&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#toList``1">toList&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#toSeq``1">toSeq&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#tryFind``1">tryFind&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#tryFindGE``1">tryFindGE&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#tryFindGT``1">tryFindGT&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#tryFindLE``1">tryFindLE&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#tryFindLT``1">tryFindLT&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#update``1">update&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#updateMax``1">updateMax&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#updateMaxWithKey``1">updateMaxWithKey&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#updateMin``1">updateMin&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#updateMinWithKey``1">updateMinWithKey&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#updateTryFindWithKey``1">updateTryFindWithKey&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#updateWithKey``1">updateWithKey&lt;a&gt;</a></li>
				<li><a href="../FSharpx.DataStructures/IntMap.htm#values``1">values&lt;a&gt;</a></li>
			</ul>
		
		
	</div>
	
	
	
	<h3 class="section">Public static methods</h3>
	
	<div id="adjust``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>adjust&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<a, a>">FSharpFunc&lt;a, a&gt;</span> f, <span title="System.int">int</span> k, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m)</h4>
		<div class="content">O(min(n,W)). Adjust a value at a specific key. When the key is not a member of the map, the original map is returned. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="adjustWithKey``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>adjustWithKey&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<int, FSharpFunc<a, a>>">FSharpFunc&lt;int, FSharpFunc&lt;a, a&gt;&gt;</span> f, <span title="System.int">int</span> k, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m)</h4>
		<div class="content">O(min(n,W)). Adjust a value at a specific key. When the key is not a member of the map, the original map is returned. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="alter``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>alter&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<FSharpOption<a>, FSharpOption<a>>">FSharpFunc&lt;FSharpOption&lt;a&gt;, FSharpOption&lt;a&gt;&gt;</span> f, <span title="System.int">int</span> k, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(log n). The expression (alter f k map) alters the value x at k, or absence thereof. alter can be used to insert, delete, or update a value in an IntMap. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="append``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>append&lt;a&gt;</strong>(<a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m1, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m2)</h4>
		<div class="content">



      
    </div>
	</div>
	<div id="appendWith``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>appendWith&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<a, FSharpFunc<a, a>>">FSharpFunc&lt;a, FSharpFunc&lt;a, a&gt;&gt;</span> f, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m1, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m2)</h4>
		<div class="content">



      
    </div>
	</div>
	<div id="appendWithKey``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>appendWithKey&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<int, FSharpFunc<a, FSharpFunc<a, a>>>">FSharpFunc&lt;int, FSharpFunc&lt;a, FSharpFunc&lt;a, a&gt;&gt;&gt;</span> f, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m1, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m2)</h4>
		<div class="content">



      
    </div>
	</div>
	<div id="concat``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>concat&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Collections.FSharpList<IntMap<a>>">FSharpList&lt;IntMap&lt;a&gt;&gt;</span> xs)</h4>
		<div class="content">Build a new array that contains the elements of each of the given list of arrays 



      
    </div>
	</div>
	<div id="concatWith``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>concatWith&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<a, FSharpFunc<a, a>>">FSharpFunc&lt;a, FSharpFunc&lt;a, a&gt;&gt;</span> f, <span title="Microsoft.FSharp.Collections.FSharpList<IntMap<a>>">FSharpList&lt;IntMap&lt;a&gt;&gt;</span> xs)</h4>
		<div class="content">



      
    </div>
	</div>
	<div id="delete``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>delete&lt;a&gt;</strong>(<span title="System.int">int</span> k, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(min(n,W)). Delete a key and its value from the map. When the key is not a member of the map, the original map is returned. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="deleteFindMax``1" class="method">
		<h4><span title="System.Tuple<Tuple<int, a>, IntMap<a>>">Tuple&lt;Tuple&lt;int, a&gt;, IntMap&lt;a&gt;&gt;</span> <strong>deleteFindMax&lt;a&gt;</strong>(<a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(log n). Retrieves the maximal key of the map, and the map stripped from that element. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="deleteFindMin``1" class="method">
		<h4><span title="System.Tuple<Tuple<int, a>, IntMap<a>>">Tuple&lt;Tuple&lt;int, a&gt;, IntMap&lt;a&gt;&gt;</span> <strong>deleteFindMin&lt;a&gt;</strong>(<a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(log n). Retrieves the minimal key of the map, and the map stripped from that element. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="deleteMax``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>deleteMax&lt;a&gt;</strong>(<a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(log n). Delete the maximal key. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="deleteMin``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>deleteMin&lt;a&gt;</strong>(<a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(log n). Delete the minimal key. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="difference``2" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>difference&lt;a, b&gt;</strong>(<a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m1, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m2)</h4>
		<div class="content">O(n+m). Difference between two maps (based on keys). Credit: Haskell.org 



      
    </div>
	</div>
	<div id="differenceWith``2" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>differenceWith&lt;a, b&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<a, FSharpFunc<b, FSharpOption<a>>>">FSharpFunc&lt;a, FSharpFunc&lt;b, FSharpOption&lt;a&gt;&gt;&gt;</span> f, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m1, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m2)</h4>
		<div class="content">O(n+m). Difference with a combining function. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="differenceWithKey``2" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>differenceWithKey&lt;a, b&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<int, FSharpFunc<a, FSharpFunc<b, FSharpOption<a>>>>">FSharpFunc&lt;int, FSharpFunc&lt;a, FSharpFunc&lt;b, FSharpOption&lt;a&gt;&gt;&gt;&gt;</span> f, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m1, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m2)</h4>
		<div class="content">O(n+m). Difference with a combining function. When two equal keys are encountered, the combining function is applied to the key and both values. If it returns Nothing, the element is discarded (proper set difference). If it returns (Just y), the element is updated with a new value y. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="exists``1" class="method">
		<h4><span title="System.bool">bool</span> <strong>exists&lt;a&gt;</strong>(<span title="System.int">int</span> k, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> _arg1)</h4>
		<div class="content">O(min(n,W)). Is the key a member of the map? Credit: Haskell.org 



      
    </div>
	</div>
	<div id="filter``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>filter&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<a, bool>">FSharpFunc&lt;a, bool&gt;</span> p, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m)</h4>
		<div class="content">O(n). Filter all values that satisfy some predicate. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="filterWithKey``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>filterWithKey&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<int, FSharpFunc<a, bool>>">FSharpFunc&lt;int, FSharpFunc&lt;a, bool&gt;&gt;</span> predicate, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> _arg1)</h4>
		<div class="content">O(n). Filter all keys/values that satisfy some predicate. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="find``1" class="method">
		<h4><span title="FSharpx.DataStructures.a">a</span> <strong>find&lt;a&gt;</strong>(<span title="System.int">int</span> k, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m)</h4>
		<div class="content">O(min(n,W)). Lookup the value at a key in the map. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="findMax``1" class="method">
		<h4><span title="System.Tuple<int, a>">Tuple&lt;int, a&gt;</span> <strong>findMax&lt;a&gt;</strong>(<a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(log n). The maximal key of the map. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="findMin``1" class="method">
		<h4><span title="System.Tuple<int, a>">Tuple&lt;int, a&gt;</span> <strong>findMin&lt;a&gt;</strong>(<a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(log n). The minimal key of the map. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="findWithDefault``1" class="method">
		<h4><span title="FSharpx.DataStructures.a">a</span> <strong>findWithDefault&lt;a&gt;</strong>(<span title="FSharpx.DataStructures.a">a</span> def, <span title="System.int">int</span> k, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> _arg1)</h4>
		<div class="content">O(min(n,W)). The expression (findWithDefault def k map) returns the value at key k or returns def when the key is not an element of the map.  Credit: Haskell.org 



      
    </div>
	</div>
	<div id="foldBack``2" class="method">
		<h4><span title="Microsoft.FSharp.Core.FSharpFunc<IntMap<a>, b>">FSharpFunc&lt;IntMap&lt;a&gt;, b&gt;</span> <strong>foldBack&lt;a, b&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<a, FSharpFunc<b, b>>">FSharpFunc&lt;a, FSharpFunc&lt;b, b&gt;&gt;</span> f, <span title="FSharpx.DataStructures.b">b</span> z)</h4>
		<div class="content">O(n). FoldBack the values in the map, such that fold f z == Prelude.foldr f z. elems. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="foldBackWithKey``2" class="method">
		<h4><span title="FSharpx.DataStructures.b">b</span> <strong>foldBackWithKey&lt;a, b&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<int, FSharpFunc<a, FSharpFunc<b, b>>>">FSharpFunc&lt;int, FSharpFunc&lt;a, FSharpFunc&lt;b, b&gt;&gt;&gt;</span> f, <span title="FSharpx.DataStructures.b">b</span> z, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(n). FoldBack the keys and values in the map, such that foldWithKey f z == Prelude.foldr (uncurry f) z. toAscList. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="foldWithKey``2" class="method">
		<h4><span title="Microsoft.FSharp.Core.FSharpFunc<IntMap<b>, a>">FSharpFunc&lt;IntMap&lt;b&gt;, a&gt;</span> <strong>foldWithKey&lt;a, b&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<a, FSharpFunc<int, FSharpFunc<b, a>>>">FSharpFunc&lt;a, FSharpFunc&lt;int, FSharpFunc&lt;b, a&gt;&gt;&gt;</span> f, <span title="FSharpx.DataStructures.a">a</span> z)</h4>
		<div class="content">O(n). Fold the keys and values in the map, such that foldWithKey f z == Prelude.foldr (uncurry f) z. toAscList. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="insert``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>insert&lt;a&gt;</strong>(<span title="System.int">int</span> k, <span title="FSharpx.DataStructures.a">a</span> x, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(min(n,W)). Insert a new key/value pair in the map. If the key is already present in the map, the associated value is replaced with the supplied value, i.e. insert is equivalent to insertWith const. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="insertTryFindWithKey``1" class="method">
		<h4><span title="System.Tuple<FSharpOption<a>, IntMap<a>>">Tuple&lt;FSharpOption&lt;a&gt;, IntMap&lt;a&gt;&gt;</span> <strong>insertTryFindWithKey&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<int, FSharpFunc<a, FSharpFunc<a, a>>>">FSharpFunc&lt;int, FSharpFunc&lt;a, FSharpFunc&lt;a, a&gt;&gt;&gt;</span> f, <span title="System.int">int</span> k, <span title="FSharpx.DataStructures.a">a</span> x, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(min(n,W)). The expression (insertLookupWithKey f k x map) is a pair where the first element is equal to (lookup k map) and the second element equal to (insertWithKey f k x map). Credit: Haskell.org 



      
    </div>
	</div>
	<div id="insertWith``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>insertWith&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<a, FSharpFunc<a, a>>">FSharpFunc&lt;a, FSharpFunc&lt;a, a&gt;&gt;</span> f, <span title="System.int">int</span> k, <span title="FSharpx.DataStructures.a">a</span> x, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(min(n,W)). Insert with a combining function. insertWith f key value mp will insert the pair (key, value) into mp if key does not exist in the map. If the key does exist, the function will insert f new_value old_value. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="insertWithKey``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>insertWithKey&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<int, FSharpFunc<a, FSharpFunc<a, a>>>">FSharpFunc&lt;int, FSharpFunc&lt;a, FSharpFunc&lt;a, a&gt;&gt;&gt;</span> f, <span title="System.int">int</span> k, <span title="FSharpx.DataStructures.a">a</span> x, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(min(n,W)). Insert with a combining function. insertWithKey f key value mp will insert the pair (key, value) into mp if key does not exist in the map. If the key does exist, the function will insert f key new_value old_value. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="intersection``2" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>intersection&lt;a, b&gt;</strong>(<a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m1, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m2)</h4>
		<div class="content">O(n+m). The (left-biased) intersection of two maps (based on keys). Credit: Haskell.org 



      
    </div>
	</div>
	<div id="intersectionWith``3" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>intersectionWith&lt;a, b, c&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<a, FSharpFunc<b, c>>">FSharpFunc&lt;a, FSharpFunc&lt;b, c&gt;&gt;</span> f, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m1, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m2)</h4>
		<div class="content">O(n+m). The intersection with a combining function. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="intersectionWithKey``3" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>intersectionWithKey&lt;a, b, c&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<int, FSharpFunc<a, FSharpFunc<b, c>>>">FSharpFunc&lt;int, FSharpFunc&lt;a, FSharpFunc&lt;b, c&gt;&gt;&gt;</span> f, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m1, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m2)</h4>
		<div class="content">O(n+m). The intersection with a combining function. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="isEmpty``1" class="method">
		<h4><span title="System.bool">bool</span> <strong>isEmpty&lt;a&gt;</strong>(<a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> _arg1)</h4>
		<div class="content">O(1). Map is empty.  Credit: Haskell.org 



      
    </div>
	</div>
	<div id="isProperSubmapOf``1" class="method">
		<h4><span title="System.bool">bool</span> <strong>isProperSubmapOf&lt;a&gt;</strong>(<a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m1, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m2)</h4>
		<div class="content">O(n+m). Is this a proper submap? (ie. a submap but not equal). Defined as (isProperSubmapOf = isProperSubmapOfBy (==)). Credit: Haskell.org 



      
    </div>
	</div>
	<div id="isProperSubmapOfBy``2" class="method">
		<h4><span title="System.bool">bool</span> <strong>isProperSubmapOfBy&lt;a, b&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<a, FSharpFunc<b, bool>>">FSharpFunc&lt;a, FSharpFunc&lt;b, bool&gt;&gt;</span> predicate, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t1, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t2)</h4>
		<div class="content">O(n+m). Is this a proper submap? (ie. a submap but not equal). The expression (isProperSubmapOfBy f m1 m2) returns True when m1 and m2 are not equal, all keys in m1 are in m2, and when f returns True when applied to their respective values.  Credit: Haskell.org 



      
    </div>
	</div>
	<div id="isSubmapOf``1" class="method">
		<h4><span title="System.bool">bool</span> <strong>isSubmapOf&lt;a&gt;</strong>(<a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m1, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m2)</h4>
		<div class="content">O(n+m). Is this a submap? Defined as (isSubmapOf = isSubmapOfBy (==)). Credit: Haskell.org 



      
    </div>
	</div>
	<div id="isSubmapOfBy``2" class="method">
		<h4><span title="System.bool">bool</span> <strong>isSubmapOfBy&lt;a, b&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<a, FSharpFunc<b, bool>>">FSharpFunc&lt;a, FSharpFunc&lt;b, bool&gt;&gt;</span> predicate, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t1, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t2)</h4>
		<div class="content">O(n+m). The expression (isSubmapOfBy f m1 m2) returns True if all keys in m1 are in m2, and when f returns True when applied to their respective values. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="keys``1" class="method">
		<h4><span title="Microsoft.FSharp.Collections.FSharpList<int>">FSharpList&lt;int&gt;</span> <strong>keys&lt;a&gt;</strong>(<a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m)</h4>
		<div class="content">O(n). Return all keys of the map in ascending order. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="map``2" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>map&lt;a, b&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<a, b>">FSharpFunc&lt;a, b&gt;</span> f, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> _arg1)</h4>
		<div class="content">O(n). Map a function over all values in the map. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="mapAccum``3" class="method">
		<h4><span title="Microsoft.FSharp.Core.FSharpFunc<a, FSharpFunc<IntMap<b>, Tuple<a, IntMap<c>>>>">FSharpFunc&lt;a, FSharpFunc&lt;IntMap&lt;b&gt;, Tuple&lt;a, IntMap&lt;c&gt;&gt;&gt;&gt;</span> <strong>mapAccum&lt;a, b, c&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<a, FSharpFunc<b, Tuple<a, c>>>">FSharpFunc&lt;a, FSharpFunc&lt;b, Tuple&lt;a, c&gt;&gt;&gt;</span> f)</h4>
		<div class="content">O(n). The function mapAccumWithKey threads an accumulating argument through the map in ascending order of keys. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="mapAccumWithKey``3" class="method">
		<h4><span title="System.Tuple<a, IntMap<c>>">Tuple&lt;a, IntMap&lt;c&gt;&gt;</span> <strong>mapAccumWithKey&lt;a, b, c&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<a, FSharpFunc<int, FSharpFunc<b, Tuple<a, c>>>>">FSharpFunc&lt;a, FSharpFunc&lt;int, FSharpFunc&lt;b, Tuple&lt;a, c&gt;&gt;&gt;&gt;</span> f, <span title="FSharpx.DataStructures.a">a</span> a, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(n). The function mapAccum threads an accumulating argument through the map in ascending order of keys. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="mapChoice``3" class="method">
		<h4><span title="Microsoft.FSharp.Core.FSharpFunc<IntMap<a>, Tuple<IntMap<b>, IntMap<c>>>">FSharpFunc&lt;IntMap&lt;a&gt;, Tuple&lt;IntMap&lt;b&gt;, IntMap&lt;c&gt;&gt;&gt;</span> <strong>mapChoice&lt;a, b, c&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<a, FSharpChoice<b, c>>">FSharpFunc&lt;a, FSharpChoice&lt;b, c&gt;&gt;</span> f)</h4>
		<div class="content">O(n). Map values and separate the Left and Right results. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="mapChoiceWithKey``3" class="method">
		<h4><span title="System.Tuple<IntMap<b>, IntMap<c>>">Tuple&lt;IntMap&lt;b&gt;, IntMap&lt;c&gt;&gt;</span> <strong>mapChoiceWithKey&lt;a, b, c&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<int, FSharpFunc<a, FSharpChoice<b, c>>>">FSharpFunc&lt;int, FSharpFunc&lt;a, FSharpChoice&lt;b, c&gt;&gt;&gt;</span> f, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> _arg1)</h4>
		<div class="content">O(n). Map keys/values and separate the Left and Right results. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="mapKeys``1" class="method">
		<h4><span title="Microsoft.FSharp.Core.FSharpFunc<IntMap<a>, IntMap<a>>">FSharpFunc&lt;IntMap&lt;a&gt;, IntMap&lt;a&gt;&gt;</span> <strong>mapKeys&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<int, int>">FSharpFunc&lt;int, int&gt;</span> f)</h4>
		<div class="content">O(n*min(n,W)). mapKeys f s is the map obtained by applying f to each key of s. The size of the result may be smaller if f maps two or more distinct keys to the same new key. In this case the value at the greatest of the original keys is retained. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="mapKeysWith``1" class="method">
		<h4><span title="Microsoft.FSharp.Core.FSharpFunc<IntMap<a>, IntMap<a>>">FSharpFunc&lt;IntMap&lt;a&gt;, IntMap&lt;a&gt;&gt;</span> <strong>mapKeysWith&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<a, FSharpFunc<a, a>>">FSharpFunc&lt;a, FSharpFunc&lt;a, a&gt;&gt;</span> c, <span title="Microsoft.FSharp.Core.FSharpFunc<int, int>">FSharpFunc&lt;int, int&gt;</span> f)</h4>
		<div class="content">O(n*log n). mapKeysWith c f s is the map obtained by applying f to each key of s. The size of the result may be smaller if f maps two or more distinct keys to the same new key. In this case the associated values will be combined using c. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="mapOption``2" class="method">
		<h4><span title="Microsoft.FSharp.Core.FSharpFunc<IntMap<a>, IntMap<b>>">FSharpFunc&lt;IntMap&lt;a&gt;, IntMap&lt;b&gt;&gt;</span> <strong>mapOption&lt;a, b&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<a, FSharpOption<b>>">FSharpFunc&lt;a, FSharpOption&lt;b&gt;&gt;</span> f)</h4>
		<div class="content">O(n). Map values and collect the Just results. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="mapOptionWithKey``2" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>mapOptionWithKey&lt;a, b&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<int, FSharpFunc<a, FSharpOption<b>>>">FSharpFunc&lt;int, FSharpFunc&lt;a, FSharpOption&lt;b&gt;&gt;&gt;</span> f, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> _arg1)</h4>
		<div class="content">O(n). Map keys/values and collect the Just results. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="mapWithKey``2" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>mapWithKey&lt;a, b&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<int, FSharpFunc<a, b>>">FSharpFunc&lt;int, FSharpFunc&lt;a, b&gt;&gt;</span> f, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> _arg1)</h4>
		<div class="content">O(n). Map a function over all values in the map. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="maxView``1" class="method">
		<h4><span title="Microsoft.FSharp.Core.FSharpOption<Tuple<a, IntMap<a>>>">FSharpOption&lt;Tuple&lt;a, IntMap&lt;a&gt;&gt;&gt;</span> <strong>maxView&lt;a&gt;</strong>(<a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(min(n,W)). Retrieves the maximal key of the map, and the map stripped of that element, or Nothing if passed an empty map. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="maxViewWithKey``1" class="method">
		<h4><span title="Microsoft.FSharp.Core.FSharpOption<Tuple<Tuple<int, a>, IntMap<a>>>">FSharpOption&lt;Tuple&lt;Tuple&lt;int, a&gt;, IntMap&lt;a&gt;&gt;&gt;</span> <strong>maxViewWithKey&lt;a&gt;</strong>(<a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(log n). Retrieves the maximal (key,value) couple of the map, and the map stripped from that element. fails (in the monad) when passed an empty map. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="mergeWithKey``3" class="method">
		<h4><span title="Microsoft.FSharp.Core.FSharpFunc<IntMap<a>, FSharpFunc<IntMap<b>, IntMap<c>>>">FSharpFunc&lt;IntMap&lt;a&gt;, FSharpFunc&lt;IntMap&lt;b&gt;, IntMap&lt;c&gt;&gt;&gt;</span> <strong>mergeWithKey&lt;a, b, c&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<int, FSharpFunc<a, FSharpFunc<b, FSharpOption<c>>>>">FSharpFunc&lt;int, FSharpFunc&lt;a, FSharpFunc&lt;b, FSharpOption&lt;c&gt;&gt;&gt;&gt;</span> f, <span title="Microsoft.FSharp.Core.FSharpFunc<IntMap<a>, IntMap<c>>">FSharpFunc&lt;IntMap&lt;a&gt;, IntMap&lt;c&gt;&gt;</span> g1, <span title="Microsoft.FSharp.Core.FSharpFunc<IntMap<b>, IntMap<c>>">FSharpFunc&lt;IntMap&lt;b&gt;, IntMap&lt;c&gt;&gt;</span> g2)</h4>
		<div class="content">Refer to Haskell documentation. Unexpected code growth or corruption of the data structure can occure from wrong use. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="minView``1" class="method">
		<h4><span title="Microsoft.FSharp.Core.FSharpOption<Tuple<a, IntMap<a>>>">FSharpOption&lt;Tuple&lt;a, IntMap&lt;a&gt;&gt;&gt;</span> <strong>minView&lt;a&gt;</strong>(<a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(min(n,W)). Retrieves the minimal key of the map, and the map stripped of that element, or Nothing if passed an empty map. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="minViewWithKey``1" class="method">
		<h4><span title="Microsoft.FSharp.Core.FSharpOption<Tuple<Tuple<int, a>, IntMap<a>>>">FSharpOption&lt;Tuple&lt;Tuple&lt;int, a&gt;, IntMap&lt;a&gt;&gt;&gt;</span> <strong>minViewWithKey&lt;a&gt;</strong>(<a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(log n). Retrieves the minimal (key,value) couple of the map, and the map stripped from that element. fails (in the monad) when passed an empty map. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="monoid``1" class="method">
		<h4><a href="../FSharpx/Monoid`1.htm">Monoid&lt;a&gt;</a> <strong>monoid&lt;a&gt;</strong>()</h4>
		<div class="content">List monoid 



      
    </div>
	</div>
	<div id="notExists``1" class="method">
		<h4><span title="System.bool">bool</span> <strong>notExists&lt;a&gt;</strong>(<span title="System.int">int</span> k, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m)</h4>
		<div class="content">O(log n). Is the key not a member of the map? Credit: Haskell.org 



      
    </div>
	</div>
	<div id="ofArray``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>ofArray&lt;a&gt;</strong>(<span title="System.Tuple`2[]">Tuple`2[]</span> xs)</h4>
		<div class="content">



      
    </div>
	</div>
	<div id="ofArrayWith``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>ofArrayWith&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<a, FSharpFunc<a, a>>">FSharpFunc&lt;a, FSharpFunc&lt;a, a&gt;&gt;</span> f, <span title="System.Tuple`2[]">Tuple`2[]</span> xs)</h4>
		<div class="content">



      
    </div>
	</div>
	<div id="ofArrayWithKey``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>ofArrayWithKey&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<int, FSharpFunc<a, FSharpFunc<a, a>>>">FSharpFunc&lt;int, FSharpFunc&lt;a, FSharpFunc&lt;a, a&gt;&gt;&gt;</span> f, <span title="System.Tuple`2[]">Tuple`2[]</span> xs)</h4>
		<div class="content">



      
    </div>
	</div>
	<div id="ofListWith``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>ofListWith&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<a, FSharpFunc<a, a>>">FSharpFunc&lt;a, FSharpFunc&lt;a, a&gt;&gt;</span> f, <span title="Microsoft.FSharp.Collections.FSharpList<Tuple<int, a>>">FSharpList&lt;Tuple&lt;int, a&gt;&gt;</span> xs)</h4>
		<div class="content">O(n*min(n,W)). Create a map from a list of key/value pairs with a combining function. See also fromAscListWith. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="ofListWithKey``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>ofListWithKey&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<int, FSharpFunc<a, FSharpFunc<a, a>>>">FSharpFunc&lt;int, FSharpFunc&lt;a, FSharpFunc&lt;a, a&gt;&gt;&gt;</span> f, <span title="Microsoft.FSharp.Collections.FSharpList<Tuple<int, a>>">FSharpList&lt;Tuple&lt;int, a&gt;&gt;</span> xs)</h4>
		<div class="content">O(n*min(n,W)). Build a map from a list of key/value pairs with a combining function. See also fromAscListWithKey'. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="ofSeqWith``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>ofSeqWith&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<a, FSharpFunc<a, a>>">FSharpFunc&lt;a, FSharpFunc&lt;a, a&gt;&gt;</span> f, <span title="System.Collections.Generic.IEnumerable<Tuple<int, a>>">IEnumerable&lt;Tuple&lt;int, a&gt;&gt;</span> xs)</h4>
		<div class="content">O(n*min(n,W)). Create a map from a seq of key/value pairs with a combining function. See also fromAscListWith. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="ofSeqWithKey``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>ofSeqWithKey&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<int, FSharpFunc<a, FSharpFunc<a, a>>>">FSharpFunc&lt;int, FSharpFunc&lt;a, FSharpFunc&lt;a, a&gt;&gt;&gt;</span> f, <span title="System.Collections.Generic.IEnumerable<Tuple<int, a>>">IEnumerable&lt;Tuple&lt;int, a&gt;&gt;</span> xs)</h4>
		<div class="content">O(n*min(n,W)). Build a map from a seq of key/value pairs with a combining function. See also fromAscListWithKey'. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="partition``1" class="method">
		<h4><span title="System.Tuple<IntMap<a>, IntMap<a>>">Tuple&lt;IntMap&lt;a&gt;, IntMap&lt;a&gt;&gt;</span> <strong>partition&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<a, bool>">FSharpFunc&lt;a, bool&gt;</span> p, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m)</h4>
		<div class="content">O(n). partition the map according to some predicate. The first map contains all elements that satisfy the predicate, the second all elements that fail the predicate. See also split. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="partitionWithKey``1" class="method">
		<h4><span title="System.Tuple<IntMap<a>, IntMap<a>>">Tuple&lt;IntMap&lt;a&gt;, IntMap&lt;a&gt;&gt;</span> <strong>partitionWithKey&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<int, FSharpFunc<a, bool>>">FSharpFunc&lt;int, FSharpFunc&lt;a, bool&gt;&gt;</span> predicate, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(n). partition the map according to some predicate. The first map contains all elements that satisfy the predicate, the second all elements that fail the predicate. See also split. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="singleton``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>singleton&lt;a&gt;</strong>(<span title="System.int">int</span> k, <span title="FSharpx.DataStructures.a">a</span> x)</h4>
		<div class="content">O(1). A map of one element. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="size``1" class="method">
		<h4><span title="System.int">int</span> <strong>size&lt;a&gt;</strong>(<a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> _arg1)</h4>
		<div class="content">O(n). Number of elements in the map. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="split``1" class="method">
		<h4><span title="System.Tuple<IntMap<a>, IntMap<a>>">Tuple&lt;IntMap&lt;a&gt;, IntMap&lt;a&gt;&gt;</span> <strong>split&lt;a&gt;</strong>(<span title="System.int">int</span> k, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(log n). The expression (split k map) is a pair (map1,map2) where all keys in map1 are lower than k and all keys in map2 larger than k. Any key equal to k is found in neither map1 nor map2. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="splitTryFind``1" class="method">
		<h4><span title="System.Tuple<IntMap<a>, FSharpOption<a>, IntMap<a>>">Tuple&lt;IntMap&lt;a&gt;, FSharpOption&lt;a&gt;, IntMap&lt;a&gt;&gt;</span> <strong>splitTryFind&lt;a&gt;</strong>(<span title="System.int">int</span> k, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(log n). Performs a split but also returns whether the pivot key was found in the original map. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="toArray``1" class="method">
		<h4><span title="System.Tuple`2[]">Tuple`2[]</span> <strong>toArray&lt;a&gt;</strong>(<a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m)</h4>
		<div class="content">O(n). Convert the map to an array of key/value pairs. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="toList``1" class="method">
		<h4><span title="Microsoft.FSharp.Collections.FSharpList<Tuple<int, a>>">FSharpList&lt;Tuple&lt;int, a&gt;&gt;</span> <strong>toList&lt;a&gt;</strong>(<a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m)</h4>
		<div class="content">O(n). Convert the map to a list of key/value pairs. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="toSeq``1" class="method">
		<h4><span title="System.Collections.Generic.IEnumerable<Tuple<int, a>>">IEnumerable&lt;Tuple&lt;int, a&gt;&gt;</span> <strong>toSeq&lt;a&gt;</strong>(<a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m)</h4>
		<div class="content">O(n). Convert the map to a seq of key/value pairs. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="tryFind``1" class="method">
		<h4><span title="Microsoft.FSharp.Core.FSharpOption<a>">FSharpOption&lt;a&gt;</span> <strong>tryFind&lt;a&gt;</strong>(<span title="System.int">int</span> k, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> _arg1)</h4>
		<div class="content">O(min(n,W)). Lookup the value at a key in the map. Returns 'a option. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="tryFindGE``1" class="method">
		<h4><span title="Microsoft.FSharp.Core.FSharpOption<Tuple<int, a>>">FSharpOption&lt;Tuple&lt;int, a&gt;&gt;</span> <strong>tryFindGE&lt;a&gt;</strong>(<span title="System.int">int</span> k, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(log n). Find smallest key greater or equal to the given one and return the corresponding (key, value) pair Credit: Haskell.org 



      
    </div>
	</div>
	<div id="tryFindGT``1" class="method">
		<h4><span title="Microsoft.FSharp.Core.FSharpOption<Tuple<int, a>>">FSharpOption&lt;Tuple&lt;int, a&gt;&gt;</span> <strong>tryFindGT&lt;a&gt;</strong>(<span title="System.int">int</span> k, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(log n). Find smallest key greater than the given one and return the corresponding (key, value) pair. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="tryFindLE``1" class="method">
		<h4><span title="Microsoft.FSharp.Core.FSharpOption<Tuple<int, a>>">FSharpOption&lt;Tuple&lt;int, a&gt;&gt;</span> <strong>tryFindLE&lt;a&gt;</strong>(<span title="System.int">int</span> k, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(log n). Find largest key smaller or equal to the given one and return the corresponding (key, value) pair. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="tryFindLT``1" class="method">
		<h4><span title="Microsoft.FSharp.Core.FSharpOption<Tuple<int, a>>">FSharpOption&lt;Tuple&lt;int, a&gt;&gt;</span> <strong>tryFindLT&lt;a&gt;</strong>(<span title="System.int">int</span> k, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(log n). Find largest key smaller than the given one and return the corresponding (key, value) pair.  Credit: Haskell.org 



      
    </div>
	</div>
	<div id="update``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>update&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<a, FSharpOption<a>>">FSharpFunc&lt;a, FSharpOption&lt;a&gt;&gt;</span> f, <span title="System.int">int</span> k, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m)</h4>
		<div class="content">O(min(n,W)). The expression (update f k map) updates the value x at k (if it is in the map). If (f x) is Nothing, the element is deleted. If it is (Just y), the key k is bound to the new value y. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="updateMax``1" class="method">
		<h4><span title="Microsoft.FSharp.Core.FSharpFunc<IntMap<a>, IntMap<a>>">FSharpFunc&lt;IntMap&lt;a&gt;, IntMap&lt;a&gt;&gt;</span> <strong>updateMax&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<a, FSharpOption<a>>">FSharpFunc&lt;a, FSharpOption&lt;a&gt;&gt;</span> f)</h4>
		<div class="content">O(log n). Update the value at the maximal key. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="updateMaxWithKey``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>updateMaxWithKey&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<int, FSharpFunc<a, FSharpOption<a>>>">FSharpFunc&lt;int, FSharpFunc&lt;a, FSharpOption&lt;a&gt;&gt;&gt;</span> f, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(log n). Update the value at the maximal key. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="updateMin``1" class="method">
		<h4><span title="Microsoft.FSharp.Core.FSharpFunc<IntMap<a>, IntMap<a>>">FSharpFunc&lt;IntMap&lt;a&gt;, IntMap&lt;a&gt;&gt;</span> <strong>updateMin&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<a, FSharpOption<a>>">FSharpFunc&lt;a, FSharpOption&lt;a&gt;&gt;</span> f)</h4>
		<div class="content">O(log n). Update the value at the minimal key. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="updateMinWithKey``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>updateMinWithKey&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<int, FSharpFunc<a, FSharpOption<a>>>">FSharpFunc&lt;int, FSharpFunc&lt;a, FSharpOption&lt;a&gt;&gt;&gt;</span> f, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(log n). Update the value at the minimal key. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="updateTryFindWithKey``1" class="method">
		<h4><span title="System.Tuple<FSharpOption<a>, IntMap<a>>">Tuple&lt;FSharpOption&lt;a&gt;, IntMap&lt;a&gt;&gt;</span> <strong>updateTryFindWithKey&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<int, FSharpFunc<a, FSharpOption<a>>>">FSharpFunc&lt;int, FSharpFunc&lt;a, FSharpOption&lt;a&gt;&gt;&gt;</span> f, <span title="System.int">int</span> k, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(min(n,W)). Lookup and update. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="updateWithKey``1" class="method">
		<h4><a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> <strong>updateWithKey&lt;a&gt;</strong>(<span title="Microsoft.FSharp.Core.FSharpFunc<int, FSharpFunc<a, FSharpOption<a>>>">FSharpFunc&lt;int, FSharpFunc&lt;a, FSharpOption&lt;a&gt;&gt;&gt;</span> f, <span title="System.int">int</span> k, <a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> t)</h4>
		<div class="content">O(min(n,W)). The expression (update f k map) updates the value x at k (if it is in the map). If (f k x) is Nothing, the element is deleted. If it is (Just y), the key k is bound to the new value y. Credit: Haskell.org 



      
    </div>
	</div>
	<div id="values``1" class="method">
		<h4><span title="Microsoft.FSharp.Collections.FSharpList<a>">FSharpList&lt;a&gt;</span> <strong>values&lt;a&gt;</strong>(<a href="../FSharpx.DataStructures/IntMap`1.htm">IntMap&lt;a&gt;</a> m)</h4>
		<div class="content">O(n). Return all elements of the map in the ascending order of their keys. Credit: Haskell.org 



      
    </div>
	</div>
	
	<div id="footer">
  <p>Based on v1.8.3.0 of FSharpx</p>
  <p>Generated by <a href="http://docu.jagregory.com">docu</a></p>
</div>
  </body>
</html>